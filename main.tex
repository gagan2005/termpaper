
%%%% CS553 Cryptography Term Paper TEMPLATE %%%%

%%%% 1. DOCUMENTCLASS %%%%
\documentclass[preprint]{transcrypto}
%%%% NOTES:
% - Change "submission" to "final" for final version
% - Add "spthm" for LNCS-like theorems


%%%% 2. PACKAGES %%%%
\usepackage{lipsum} % Example package -- can be removed
\usepackage[ruled,vlined]{algorithm2e}
\usepackage[T1]{fontenc}
\usepackage{amssymb}
%%%% 3. AUTHOR, INSTITUTE %%%%
\author{Gagan deep singh\inst{1} \and Siram Nikhil\inst{1} \and Kolli Madhukar\inst{1}}
\institute{
 Indian Institute of Technology, Bhilai, India 
}
%%%% NOTES:
% - We need a city name for indexation purpose, even if it is redundant
%   (eg: University of Atlantis, Atlantis, Atlantis)
% - \inst{} can be omitted if there is a single institute,
%   or exactly one institute per author


%%%% 4. TITLE %%%%
\title{KLIEN CIPHER}
%%%% NOTES:
% - If the title is too long, or includes special macro, please
%   provide a "running title" as optional argument: \title[Short]{Long}
% - You can provide an optional subtitle with \subtitle.

\begin{document}

\maketitle


%%%% 5. KEYWORDS %%%%
\keywords{Block Cipher \and Low Resource Implementation \and  Ubiquitous computing. }
%%%% 6. ABSTRACT %%%%
\begin{abstract}
  ---------------------------------------------------- Lorem
\end{abstract}


%%%% 7. PAPER CONTENT %%%%
\section{Introduction}
As the development and usage of wireless computing and embedded systems is increasing. we are being increasingly dependent on Ubiquitous computing examples are sensors, RFID tags etc. On these limited resource systems the selection of the security algorithms must be done carefully by taking the implementation costs along with the level of security provided. So the Era of light-weight cryptography is started. Many algorithms with various design strategies were proposed.Few of them were skipjack, KATAN, KTANTAN, PRESENT etc. skipjack is 8 bit key and 64-bit block length cipher whose basic design is based on unbalanced feistal network. PRESENT is 80/128 bit key and 64 bit block size cipher  which is extremely hardware efficient as the diffusion layer constitutes of only wiring with no algebraic unit.
Before wide implementation of a security algorithm, it should be thoroughly analysed. As the result of these analysis an attack on 31 out of 32 rounds of skipjack based on impossible differential is discovered. Also there are weak key attacks and linear attacks on PRESENT.Hence the need of secure lightweight-ciphers did not came to and end. KLEIN is a lightweight block cipher which is created for resource constrained devices like sensors. KLEIN is based on Substitution Permutation Networks. In this paper we will be seeing the working of KLEIN cipher, implementation details and different attacks performed on it along with the comparison of performance and security among few other .
\section{Design rationale}
In this section we will be discussing about design rationale chosen when creating KLEIN ciphers.
\\
KLEIN is collection of ciphers of different key length(64, 80, and 96) and fixed 64 bit block length.
We shall denote these ciphers as KLEIN-64/80/96 based on their key lengths.We know that block cipher's security and implementation cost mainly depends on the key size and block size. Keeping in mind that lightweight ciphers are used in resource constrained machines like sensors, RFIDs, the block length is decided to be 64 bits as high-throughput is not expected in these devices as large block lengths and larger keys are unnecessary.As 64 bit key length might be little vulnerable if we consider attacks based on pre-computation and large storage capacities, it is suggested to use KLEIN-64 for message authentication codes and hash functions, Where as KLEIN-80/96 are to be used for encryption in any of the modes of operation.\\

\subsection{Optimal Platform} Generally light weight ciphers are optimized for hardware implementation as they are used in RFID tags and smart cards. But if a system can support the computation and memory requirements if the software implementation, the costs of manufacturing and maintenance will reduce drastically as we can simply update the implementation of the cipher by simply installing a software update. They are also more flexible. So they mainly focused on the software implementation of KLEIN. 
But both the software and hardware implementations are light weight.\\
\subsection{Critical Threats}
At the basic, the cipher should be resistant to general attacks like differential and linear. An for a cipher to be secure enough and implemented widely it should also be resistant to the related key attacks and the ones which belong to Grey box model like side channel attacks. Even if the sensor nodes are compromised they should not be able to crack the cipher. But generally the hardware implementations are vulnerable to the side channel attacks like differential power analysis etc. The protection methods of these side channel attacks like Blindfolding, making and re-keying techniques are suitable enough for normal ciphers in terms implementation costs. For lightweight ciphers their costs should as minimal as possible. The Key schedule of KLEIN is said to balanced enough as it is resistant against related key attacks. \\

\section{Specification of KLEIN}

\subsection{Structure of KLEIN}
KLEIN is made of Substitution-Permutation-Network(SPN) which is also used in popular ciphers like AES and PRESENT. By taking into the consideration of security margin and the asymmetric iteration we chose 12/16/20 rounds for KLIEN-64/80/96 respectively.$N_{R}$ is used to represent the number of rounds.\\
The pseudo-code of KLEIN is displayed below.\\

\begin{algorithm}[H]
\SetAlgoLined
$sk^{1}\gets KEY$; \\
STATE $\gets$ PLAINTEXT;\\
\For{$i=1$ \KwTo $N_{R}$ }{
    $AddRoundKey(\text{STATE}, sk i );$\\
$SubN ibbles(\text{STATE});$ \\
$RotateN ibbles(\text{STATE});$ \\
$M ixN ibbles(\text{STATE});$ \\
$sk i+1 = KeySchedule(sk i , i);$ \\
 }
 CIPHERTEXT $\gets AddRoundKey(\text{STATE}, sk^{N_{R}+1} )$;
 \caption{KLEIN CIPHER}
\end{algorithm}
\subsection{Round Transformation}
The Input and Out put of KLEIN is in terms of one-dimensional array of bytes. All the steps in each round can be optimized by byte-oriented algorithms. \textbf{Image should be added here}.
\subsubsection{SubNibbles step}
Before this step, the input will be xored with the corresponding round key. The obtained resultant state is passed to subnibbles where the state is divided into 16 4-bit nibbles and given as input to the 4 x 4 Involutive permutation. Involutiveness of S-box is helpful to degrees the implementation costs of calculating its inverse and also the need of protection against side channel attacks is removed as we only need to protect single S-box. The S-box is displayed below.
\begin{center}\begin{math}
\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
Input &0 &1 &2 &3 &4 &5 &6 &7 &8 &9 &A &B &C & D& E& F&  
    \hline
Output &7 &4 &A &9 &1 &F &B &0 &C &3 &2 &6 &8 &E &D &5 & 
\hline
\end{array}
\end{math}
\end{center}
To obtain the required resistance against linear and differential cryptanalysis, The Sbox should have this properties:
\begin{enumerate}
    \item It satisfies $S(S(x)) = x, x \in \mathbb{F}^{4}_{2} $, as it is said to be Involutive.
    \item  It should not contain any fixed points i.e S(x)$\neq$x, where  $x \in \mathbb{F}^{4}_{2} $.
    \item For any non-zero input diff($\Delta_{I}$) and output diff($\Delta_{O}$) that belong to  $\mathbb{F}^{4}_{2} $, It should follow:
    $$ \#\{x \in \mathbb{F}^{4}_{2} | S(x) \oplus S(x \oplus \Delta_{I} ) = \Delta_{O} \} \leq 4$$.
    Furthermore, if $wt(\Delta_{I} ) = wt(\Delta{O} )=1$, where $wt(X)=\sum_{i}X_{i}\;$($X_{i}$ is ith bit of X) , we have
$$\#\{x \in \mathbb{F}^{4}_{2} |S(x) + S(x + \Delta_{I} ) = \Delta_{O} \} \leq 2$$.
\end{enumerate}


% \label{sec:main}


\section{Key Schedule}
We call the original key as master key and denote it as $mk$. It will be of 64/80/96 bit for  KLIEN 64/80/96. As a result of key scheduling algorthm 8/10/12  subkeys with length same as master key will be generated for KLIEN 64/80/96. Without LOG we will talk about key scheduling of KLEIN 64 \\

\begin{itemize}

\item The first subkey $sk_{0}$ is same as the master key \\
	$sk_{0}$=$mk$.Each of the subsequent $sk_{i+1}$ will be derived from $sk_{i}$ as follows - \\

\item Denote $sk_{i}$ as a tuple of bytes - (x0 x1 x2 x3 x4 x5 x6 x7) \\
Divide the tuple into two equal parts and call them a and b 

a - (x0 x1 x2 x3) \\
b - (x4 x5 x6 x7) \\

\item Now Perform one byte left circular shift to both a and b

a' = (x1 x2 x3 x0) \\
b' = (x7 x4 x5 x6) \\

\item Swap a' and b' i.e a'' = b' and b''=a' \\

\item Now let a'' = (y0 y1 y2 y3) \\
and b'' = (z0 z1 z2 z3) \\

We will Xor the round counter i with 3rd byte of a'' and pass 2nd and 3rd byte of b'' through the KLIEN S-BOX and then a''|b'' will become the next subkey \\
$sk_{i+1}$ = (y0 y1 $ y2 \oplus R_i $ y3 z0 Sbox(z1) Sbox(z2) z4)\\
\end{itemize}

\section{Main Result}
\label{sec:main}

%%%% 8. BILBIOGRAPHY %%%%
\bibliographystyle{alpha}
\bibliography{abbrev3,crypto,biblio}
%%%% NOTES
% - Download abbrev3.bib and crypto.bib from https://cryptobib.di.ens.fr/
% - Use bilbio.bib for additional references not in the cryptobib database.
%   If possible, take them from DBLP.

\end{document}

